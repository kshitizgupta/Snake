<!DOCTYPE html>
<html>
<head lang="en">
  <meta charset="UTF-8">
  <title>Snake Game</title>
</head>
<body style="color: black; font-weight: bold; background-color: aliceblue; font-family: cursive">

<div id="Menu" class="col-md-6" style="align-content: center">
  <div class="row" style="height: 50px">
    <div id="game_score" class="col-md-3">
      SCORE : <span></span>
    </div>

    <div id="disp_msg" class="col-md-3"></div>

  </div>
  <button id="start" style="cursor: pointer">
    Start
  </button>
</div>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js">

</script>
<script>
  var msgObj = {
    WELCOME: "Welcome PYTHON, born in JAVA, in relationship with <i>MONGODB</i>, JOB: eat <i>JAVASCRIPT<i>....R u <i>REDIS</i>, press start",
    GAME_OVER: "<i>!!!OOPS!!!</i>GAME OVER. Return with more OBJECTS next time, hail OBJECT ORIENTED PROGRAMMING",
    SELF_COLLIDE: "R u kidding me, u ate urself, WHAT R U?? a BUG ? Lemme fix you"
  };
  var displayMsg = '';
  $(document).ready(function () {
    $('#disp_msg').html(msgObj.WELCOME);
  });
  $('#start').click(function () {
    reset();
  });
  // CONSTANTS
  var ROW = 26;
  var COL = 26;

  //DIRECTION KEYS
  var KEY_LEFT = 37;
  var KEY_UP = 38;
  var KEY_RIGHT = 39;
  var KEY_DOWN = 40;

  var DIRECTION = {
    UP: 0,
    RIGHT: 1,
    DOWN: 2,
    LEFT: 3
  };

  var COLLISION_TYPE = {
    FOOD: 1,
    WALL: 2,
    SELF: 3
  };

  var GRID_VAL = {
    EMPTY: 0,
    SNAKE: 1,
    FOOD: 2
  };

  /**
   * Represents a Point in the Game Grid
   * @param x
   * @param y
   * @constructor
   */
  var Point = function (x, y) {
    this.x = x;
    this.y = y;
  };

  var Snake = function (point) {
    this.currDir = DIRECTION.RIGHT;
    this.snakeArr = [];
    this.snakeArr.push(new Point(point.x, point.y));
  };

  Snake.prototype.getHead = function () {
    var snakeLength = this.snakeArr.length;
    var snakeHead = this.snakeArr[snakeLength - 1];
    return snakeHead;
  };

  Snake.prototype.changeDir = function (direction) {
    var snakeLength = this.snakeArr.length;
    var snakeHead = this.snakeArr[snakeLength - 1];

    switch (direction) {
      case DIRECTION.UP:
        if (this.currDir != DIRECTION.DOWN) {
          this.currDir = DIRECTION.UP;
        }
        break;

      case DIRECTION.DOWN:
        if (this.currDir != DIRECTION.UP) {
          this.currDir = DIRECTION.DOWN;
        }
        break;

      case DIRECTION.LEFT:
        if (this.currDir != DIRECTION.RIGHT) {
          this.currDir = DIRECTION.LEFT;
        }
        break;
      case DIRECTION.RIGHT:
        if (this.currDir != DIRECTION.LEFT) {
          this.currDir = DIRECTION.RIGHT;
        }
        break;
      default :
        break;
    }
  };

  Snake.prototype.crawl = function () {
    var snakeLength = this.snakeArr.length - 1;
    var snakeHead = this.snakeArr[snakeLength];

    switch (this.currDir) {
      case DIRECTION.UP:
        this.currDir = DIRECTION.UP;
        this.snakeArr.push(new Point(snakeHead.x, snakeHead.y - 1));
        this.snakeArr.splice(0, 1);
        break;

      case DIRECTION.DOWN:
        this.currDir = DIRECTION.DOWN;
        this.snakeArr.push(new Point(snakeHead.x, snakeHead.y + 1));
        this.snakeArr.splice(0, 1);
        break;

      case DIRECTION.LEFT:
        this.currDir = DIRECTION.LEFT;
        this.snakeArr.push(new Point(snakeHead.x - 1, snakeHead.y));
        this.snakeArr.splice(0, 1);
        break;

      case DIRECTION.RIGHT:
        this.currDir = DIRECTION.RIGHT;
        this.snakeArr.push(new Point(snakeHead.x + 1, snakeHead.y));
        this.snakeArr.splice(0, 1);
        break;
      default :
        break;
    }
  };

  //Draws the snake on the canvas
  Snake.prototype.drawSnake = function () {
    for (var i = 0; i < mySnake.snakeArr.length; i++) {
      var currPoint = mySnake.snakeArr[i];
      ctx.fillStyle = 'white';
      ctx.fillRect(currPoint.x * tileSize, currPoint.y * tileSize, tileSize, tileSize);
    }
  };

  Snake.prototype.grow = function () {
    var snakeTail = this.snakeArr[0];
    switch (this.currDir) {
      case DIRECTION.UP:
//        this.snakeArr.unshift(snakeTail.x, snakeTail.y + 1);
        this.snakeArr.unshift(new Point(snakeTail.x, snakeTail.y + 1));
        break;
      case DIRECTION.DOWN:
        this.snakeArr.unshift(new Point(snakeTail.x, snakeTail.y - 1));
        break;
      case DIRECTION.LEFT:
        this.snakeArr.unshift(new Point(snakeTail.x + 1, snakeTail.y));
        break;
      case DIRECTION.RIGHT:
        this.snakeArr.unshift(new Point(snakeTail.x - 1, snakeTail.y));
        break;
    }
  };

  Snake.prototype.didSelfCollide = function () {
    var snakeLength = this.snakeArr.length;
    var snakeHead = this.snakeArr[snakeLength - 1];

    for (var i = snakeLength - 4; i >= 0; i--) {
      if (snakeHead.x == this.snakeArr[i].x && snakeHead.y == this.snakeArr[i].y) {
        return true;
      }
    }
    return false;
  };

  Snake.prototype.collide = function (type) {
    switch (type) {
      case COLLISION_TYPE.FOOD:
        this.grow();
        break;
      case COLLISION_TYPE.WALL:
      case COLLISION_TYPE.SELF:
        break;
      default :
        break;
    }
  };


  var Food = function () {
    this.location = null;
    this.cookFood = function () {
      var x = Math.round(Math.random() * (ROW - 1));
      var y = Math.round(Math.random() * (COL - 1));
      this.location = new Point(x, y);
    };

    this.isFoodPresent = function () {
      if (this.location == null) {
        return false;
      } else {
        return true;
      }
    };

    this.drawFood = function drawFood() {
      if (this.location == null) return;
      ctx.fillStyle = "red";
      ctx.fillRect(this.location.x * tileSize, this.location.y * tileSize, tileSize, tileSize);
    };

    this.removeFood = function () {
      this.location = null;
    }

  };

  /*
   var GameGrid = function (width, height) {
   this.width = width;
   this.height = height;
   this.grid = [];
   for (var i = 0; i < this.width; i++) {
   this.grid[i] = [];
   for (var j = 0; j < this.height; j++) {
   this.grid[i][j] = GRID_VAL.EMPTY;
   }
   }
   };

   GameGrid.prototype.initGrid = function () {
   //for();
   };

   GameGrid.prototype.get = function (point) {
   return this.grid[point.x][point.y];
   };

   GameGrid.prototype.set = function (point) {
   this.grid[point.x][point.y] = 1;
   };

   GameGrid.prototype.unSet = function (point) {
   this.grid[point.x][point.y] = 0;
   };
   */

  //Game Objects
  var canvas,
      ctx,
      grid,
      mySnake
      ;
  var speed = 15;
  var tileSize = 20;
  var food = null;
  var score = 0;
  var gameThread = null;


  function main() {
    canvas = document.createElement("canvas");
    canvas.width = COL * tileSize;
    canvas.height = ROW * tileSize;
    ctx = canvas.getContext("2d");
    document.body.appendChild(canvas);
    paintCanvas();
  }

  function init() {
    var midPoint = new Point(COL / 2, ROW / 2);
    mySnake = new Snake(midPoint);
    food = new Food();
    gameThread = setInterval(draw, 1000 / speed);
    listenSnakeMovement();
    updateScore();
  }

  function reset() {
    $('#disp_msg').html(msgObj.WELCOME);
    score = 0;
    updateScore();
    init();
  }

  function listenSnakeMovement() {
    document.onkeydown = function (e) {
      var key = e.keyCode;

      if (key == KEY_LEFT) {
        setTimeout(mySnake.changeDir(DIRECTION.LEFT), 30);
      } else if (key == KEY_UP) {
        setTimeout(mySnake.changeDir(DIRECTION.UP), 30);
      } else if (key == KEY_RIGHT) {
        setTimeout(mySnake.changeDir(DIRECTION.RIGHT), 30);
      } else if (key == KEY_DOWN) {
        setTimeout(mySnake.changeDir(DIRECTION.DOWN), 30);
      }
      if (key) e.preventDefault();
    }
  }

  //Draws the canvas
  function paintCanvas() {
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }

  function updateScore() {
    $('#game_score').find('span').html(score);
  }


  function handleCollision() {
    if (food && food.location && food.location.x == mySnake.getHead().x
        && food.location.y == mySnake.getHead().y) {
      mySnake.collide(COLLISION_TYPE.FOOD);
      score++;
      updateScore();
      food.removeFood();
//      food.cookFood();
      return;
    }

    //Collision with side walls
    if (mySnake.getHead().x >= ROW || mySnake.getHead().y >= COL ||
        mySnake.getHead().x < 0 || mySnake.getHead().y < 0) {
      displayMsg = '' + msgObj.GAME_OVER;
      gameOver();
      clearInterval(gameThread);
      return;
    }

    //Collision with snake itself
    if (mySnake.didSelfCollide() == true) {
      displayMsg = '' + msgObj.SELF_COLLIDE + '\n';
      displayMsg += msgObj.GAME_OVER;
      gameOver();
      clearInterval(gameThread);
    }
  }

  function gameOver() {
    var $gameOver = $('#disp_msg');

    $gameOver.show();
    if (displayMsg && displayMsg != '') {
      $gameOver.html(displayMsg);
    } else {
      $gameOver.html(msgObj.disp_msg);
    }
  }

  function draw() {
    paintCanvas();
    mySnake.crawl();
    mySnake.drawSnake();
    if (!food.isFoodPresent()) {
      food.cookFood();
    }
    food.drawFood();

    handleCollision();
  }

  main();
</script>

</body>
</html>